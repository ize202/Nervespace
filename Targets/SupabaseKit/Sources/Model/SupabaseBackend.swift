//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

@MainActor
public class DB: ObservableObject {
	/// Variable reference to access Supabase.
	internal let _db: SupabaseClient
	
	/// User service for handling user-related operations
	public private(set) lazy var userService: UserService = {
		SupabaseUserService(client: _db)
	}()
	
	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil
	
	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut
	
	/// Progress tracking properties
	@Published public private(set) var currentStreak: Int = 0
	@Published public private(set) var totalMinutes: Int = 0
	@Published public private(set) var routineCompletions: Int = 0
	@Published public private(set) var lastActivity: Date?
	
	/// Routine completion history
	@Published public private(set) var recentCompletions: [RoutineCompletion] = []
	
	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?
	
	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?
	
	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?
	
	private let defaults = UserDefaults.standard
	private let deviceIdKey = "device_uuid"
	
	/// Device UUID for anonymous users
	private var deviceId: UUID {
		if let storedId = defaults.string(forKey: deviceIdKey),
		   let uuid = UUID(uuidString: storedId) {
			return uuid
		}
		let newId = UUID()
		defaults.set(newId.uuidString, forKey: deviceIdKey)
		return newId
	}
	
	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	public init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {
		#if DEBUG
		let urlKey = "SUPABASE_DEV_URL"
		let apiKeyKey = "SUPABASE_DEV_KEY"
		print("[DB] Using development database")
		#else
		let urlKey = "SUPABASE_URL"
		let apiKeyKey = "SUPABASE_KEY"
		print("[DB] Using production database")
		#endif
		
		let supabaseURLString = try? getPlistEntry(urlKey, in: "Supabase-Info")
		let apiKey = try? getPlistEntry(apiKeyKey, in: "Supabase-Info")
		
		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR: Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}
		
		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)
		
		Task {
			await registerAuthStateListener(additionalHandler: onAuthStateChange)
		}
	}
	
	// MARK: - Progress Tracking
	
	private func loadLocalProgress() {
		currentStreak = defaults.integer(forKey: "local_streak")
		totalMinutes = defaults.integer(forKey: "local_minutes")
		routineCompletions = defaults.integer(forKey: "local_completions")
		lastActivity = defaults.object(forKey: "local_last_activity") as? Date
	}
	
	private func saveLocalProgress() {
		defaults.set(currentStreak, forKey: "local_streak")
		defaults.set(totalMinutes, forKey: "local_minutes")
		defaults.set(routineCompletions, forKey: "local_completions")
		defaults.set(lastActivity, forKey: "local_last_activity")
	}
	
	public func loadProgress() async throws {
		if authState == .signedIn, let userId = currentUser?.id {
			let progress = try await userService.fetchProgress(userId: userId)
			updateProgress(from: progress)
			// Also load completions
			await loadRecentCompletions()
		} else {
			do {
				let progress = try await userService.fetchProgress(userId: deviceId)
				updateProgress(from: progress)
				// Also load completions
				await loadRecentCompletions()
			} catch {
				print("No remote progress found for anonymous user, using local")
				loadLocalProgress()
			}
		}
	}
	
	@MainActor
	private func updateProgress(from progress: UserProgress) {
		currentStreak = progress.streak
		totalMinutes = progress.totalMinutes
		routineCompletions = progress.routineCompletions
		lastActivity = progress.lastActivity
		saveLocalProgress()
	}
	
	public func recordCompletion(routine: Routine) async throws {
		let today = Date()
		let calendar = Calendar.current
		
		// First record the completion in the completions table
		let userId = currentUser?.id
		let completionId: UUID = try await userService.recordRoutineCompletion(
			routineId: routine.id,
			userId: userId,
			deviceId: userId == nil ? deviceId : nil
		)
		
		// Then update local state
		currentStreak = try await userService.getCurrentStreak(userId: userId ?? deviceId)
		lastActivity = today
		totalMinutes += routine.totalDuration / 60
		routineCompletions += 1
		saveLocalProgress()
		
		// Fetch recent completions
		await loadRecentCompletions()
	}
	
	public func loadRecentCompletions() async {
		do {
			let userId = currentUser?.id
			let completions = try await userService.getRecentCompletions(
				userId: userId,
				deviceId: userId == nil ? deviceId : nil,
				days: 30 // Fetch last 30 days of completions
			)
			await MainActor.run {
				self.recentCompletions = completions
			}
		} catch {
			print("[DB] Failed to load recent completions: \(error.localizedDescription)")
		}
	}
	
	// Call this when user creates an account to migrate anonymous data
	public func migrateProgress(to userId: UUID) async throws {
		guard authState == .signedIn else { return }
		
		// Create new progress entry for authenticated user
		let progress = try await userService.updateProgress(
			userId: userId,
			streak: currentStreak,
			routineCompletions: routineCompletions,
			totalMinutes: totalMinutes,
			lastActivity: lastActivity
		)
		// Update local state with server response
		updateProgress(from: progress)
	}
}
