//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

@MainActor
public class DB: ObservableObject {
	/// Variable reference to access Supabase.
	internal let _db: SupabaseClient
	
	/// User service for handling user-related operations
	public private(set) lazy var userService: UserService = {
		SupabaseUserService(client: _db)
	}()
	
	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil
	
	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut
	
	/// Progress tracking properties
	@Published public private(set) var currentStreak: Int = 0
	@Published public private(set) var totalMinutes: Int = 0
	@Published public private(set) var routineCompletions: Int = 0
	@Published public private(set) var lastActivity: Date?
	
	/// Routine completion history
	@Published public private(set) var recentCompletions: [RoutineCompletion] = []
	
	/// Initialization state
	@Published private(set) var isInitialized = false
	
	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?
	
	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?
	
	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?
	
	private let defaults = UserDefaults.standard
	private let deviceIdKey = "device_uuid"
	
	/// Device UUID for anonymous users
	private var deviceId: UUID {
		if let storedId = defaults.string(forKey: deviceIdKey),
		   let uuid = UUID(uuidString: storedId) {
			return uuid
		}
		let newId = UUID()
		defaults.set(newId.uuidString, forKey: deviceIdKey)
		return newId
	}
	
	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	public init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {
		#if DEBUG
		let urlKey = "SUPABASE_DEV_URL"
		let apiKeyKey = "SUPABASE_DEV_KEY"
		print("[DB] Using development database")
		#else
		let urlKey = "SUPABASE_URL"
		let apiKeyKey = "SUPABASE_KEY"
		print("[DB] Using production database")
		#endif
		
		let supabaseURLString = try? getPlistEntry(urlKey, in: "Supabase-Info")
		let apiKey = try? getPlistEntry(apiKeyKey, in: "Supabase-Info")
		
		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR: Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}
		
		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)
		
		Task {
			do {
				await registerAuthStateListener(additionalHandler: onAuthStateChange)
				
				// Initialize anonymous progress if needed
				if self.authState == .signedOut {
					print("[DB] Checking for existing anonymous progress...")
					do {
						let progress = try await userService.fetchProgressByDeviceId(deviceId)
						print("[DB] Found existing anonymous progress with streak: \(progress.streak)")
						await MainActor.run {
							updateProgress(from: progress)
						}
					} catch let error as NSError {
						if error.domain == "UserService" && error.code == 404 {
							print("[DB] No existing progress found, initializing anonymous user progress...")
							do {
								let progress = try await userService.initializeAnonymousProgress(deviceId: deviceId)
								print("[DB] Successfully initialized anonymous progress with ID: \(progress.id)")
								await MainActor.run {
									updateProgress(from: progress)
								}
							} catch {
								print("[DB] Error initializing anonymous progress: \(error.localizedDescription)")
								// Load local progress as fallback
								loadLocalProgress()
							}
						} else {
							print("[DB] Error checking progress: \(error.localizedDescription)")
							// Load local progress as fallback
							loadLocalProgress()
						}
					}
				}
				
				await MainActor.run {
					self.isInitialized = true
				}
			} catch {
				print("[DB] Error during initialization: \(error.localizedDescription)")
				// Even if initialization fails, we should still mark as initialized to prevent hanging
				await MainActor.run {
					self.isInitialized = true
					// Load local progress as fallback
					loadLocalProgress()
				}
			}
		}
	}
	
	// MARK: - Progress Tracking
	
	private func loadLocalProgress() {
		currentStreak = defaults.integer(forKey: "local_streak")
		totalMinutes = defaults.integer(forKey: "local_minutes")
		routineCompletions = defaults.integer(forKey: "local_completions")
		lastActivity = defaults.object(forKey: "local_last_activity") as? Date
	}
	
	private func saveLocalProgress() {
		defaults.set(currentStreak, forKey: "local_streak")
		defaults.set(totalMinutes, forKey: "local_minutes")
		defaults.set(routineCompletions, forKey: "local_completions")
		defaults.set(lastActivity, forKey: "local_last_activity")
	}
	
	public func loadProgress() async throws {
		if authState == .signedIn, let userId = currentUser?.id {
			let progress = try await userService.fetchProgress(userId: userId)
			updateProgress(from: progress)
			// Also load completions
			await loadRecentCompletions()
		} else {
			do {
				let progress = try await userService.fetchProgressByDeviceId(deviceId)
				updateProgress(from: progress)
				// Also load completions
				await loadRecentCompletions()
			} catch {
				print("No remote progress found for anonymous user, using local")
				loadLocalProgress()
			}
		}
	}
	
	@MainActor
	private func updateProgress(from progress: UserProgress) {
		currentStreak = progress.streak
		totalMinutes = progress.totalMinutes
		routineCompletions = progress.routineCompletions
		lastActivity = progress.lastActivity
		saveLocalProgress()
	}
	
	public func recordCompletion(routine: Routine) async throws {
		if !isInitialized {
			print("[DB] Waiting for initialization to complete...")
			// Wait for initialization with a timeout
			for _ in 0..<10 { // 1 second timeout
				if isInitialized { break }
				try await Task.sleep(nanoseconds: 100_000_000) // 0.1 second
			}
			
			guard isInitialized else {
				print("[DB] Initialization timed out")
				throw NSError(domain: "DB", code: 500, userInfo: [
					NSLocalizedDescriptionKey: "Database initialization timed out"
				])
			}
		}
		
		let today = Date()
		let userId = currentUser?.id
		let deviceIdForCompletion = userId == nil ? deviceId : nil
		
		print("[DB] Recording completion for \(userId?.uuidString ?? "anonymous")/\(deviceIdForCompletion?.uuidString ?? "no device")")
		
		// Record the completion in the completions table
		let completionId: UUID = try await userService.recordRoutineCompletion(
			routineId: routine.id,
			userId: userId,
			deviceId: deviceIdForCompletion
		)
		
		print("[DB] Successfully recorded completion with ID: \(completionId)")
		
		// Update local state
		currentStreak = try await userService.getCurrentStreak(userId: userId ?? deviceId)
		lastActivity = today
		totalMinutes += routine.totalDuration / 60
		routineCompletions += 1
		saveLocalProgress()
		
		// Fetch recent completions
		await loadRecentCompletions()
	}
	
	public func loadRecentCompletions() async {
		do {
			let userId = currentUser?.id
			let completions = try await userService.getRecentCompletions(
				userId: userId,
				deviceId: userId == nil ? deviceId : nil,
				days: 30 // Fetch last 30 days of completions
			)
			await MainActor.run {
				self.recentCompletions = completions
			}
		} catch {
			print("[DB] Failed to load recent completions: \(error.localizedDescription)")
		}
	}
	
	// Call this when user creates an account to migrate anonymous data
	public func migrateProgress(to userId: UUID) async throws {
		guard authState == .signedIn else { return }
		
		// Create new progress entry for authenticated user
		let progress = try await userService.updateProgress(
			userId: userId,
			streak: currentStreak,
			routineCompletions: routineCompletions,
			totalMinutes: totalMinutes,
			lastActivity: lastActivity
		)
		// Update local state with server response
		updateProgress(from: progress)
	}
}
