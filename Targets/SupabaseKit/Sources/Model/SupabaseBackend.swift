//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

@MainActor
public class DB: ObservableObject {
	/// Variable reference to access Supabase.
	internal let _db: SupabaseClient
	
	/// User service for handling user-related operations
	public private(set) lazy var userService: UserService = {
		SupabaseUserService(client: _db)
	}()
	
	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil
	
	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut
	
	/// Progress tracking properties
	@Published public private(set) var currentStreak: Int = 0
	@Published public private(set) var dailyMinutes: Int = 0
	@Published public private(set) var totalMinutes: Int = 0
	@Published public private(set) var lastActivity: Date?
	
	/// Routine completion history
	@Published public private(set) var recentCompletions: [Model.RoutineCompletion] = []
	
	/// Initialization state
	@Published private(set) var isInitialized = false
	
	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?
	
	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?
	
	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?
	
	private let defaults = UserDefaults.standard
	private let deviceIdKey = "device_uuid"
	
	/// Device UUID for anonymous users
	private var deviceId: UUID {
		if let storedId = defaults.string(forKey: deviceIdKey),
		   let uuid = UUID(uuidString: storedId) {
			return uuid
		}
		let newId = UUID()
		defaults.set(newId.uuidString, forKey: deviceIdKey)
		return newId
	}
	
	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	public init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {
		#if DEBUG
		let urlKey = "SUPABASE_DEV_URL"
		let apiKeyKey = "SUPABASE_DEV_KEY"
		print("[DB] Using development database")
		#else
		let urlKey = "SUPABASE_URL"
		let apiKeyKey = "SUPABASE_KEY"
		print("[DB] Using production database")
		#endif
		
		let supabaseURLString = try? getPlistEntry(urlKey, in: "Supabase-Info")
		let apiKey = try? getPlistEntry(apiKeyKey, in: "Supabase-Info")
		
		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR: Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}
		
		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)
		
		Task {
			await registerAuthStateListener(additionalHandler: onAuthStateChange)
			try? await loadProgress()
		}
	}
	
	// MARK: - Progress Tracking
	
	public func loadProgress() async throws {
		let progress: Model.UserProgress
		if authState == .signedIn, let userId = currentUser?.id {
			progress = try await userService.fetchProgress(userId: userId)
		} else {
			progress = try await userService.fetchProgressByDeviceId(deviceId)
		}
		
		// Update state with server data
		await MainActor.run {
			currentStreak = progress.streak
			dailyMinutes = progress.dailyMinutes
			totalMinutes = progress.totalMinutes
			lastActivity = progress.lastActivity
		}
		
		// Load completions
		await loadRecentCompletions()
	}
	
	public func recordCompletion(
		routine: SharedKit.Routine,
		durationMinutes: Int
	) async throws -> UUID {
		try await userService.recordRoutineCompletion(
			routineId: routine.id,
			durationMinutes: durationMinutes,
			userId: currentUser?.id,
			deviceId: currentUser == nil ? deviceId : nil
		)
	}
	
	public func loadRecentCompletions() async {
		do {
			let userId = currentUser?.id
			let completions = try await userService.getRecentCompletions(
				userId: userId,
				deviceId: userId == nil ? deviceId : nil,
				days: 30
			)
			await MainActor.run {
				self.recentCompletions = completions
			}
		} catch {
			print("[DB] Failed to load recent completions: \(error.localizedDescription)")
		}
	}
	
	// MARK: - Account Migration
	
	public func migrateProgress(to userId: UUID) async throws {
		guard authState == .signedIn else { return }
		try await userService.migrateAnonymousProgress(from: deviceId, to: userId)
		try await loadProgress()
	}
}
