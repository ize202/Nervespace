//
//  SignInWithApple.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/authkit/sign-in-with-apple-flow
//

import AuthenticationServices
import CryptoKit
import Supabase

// MARK: - Sign in with Apple
extension DB {

	public func handleSignInWithAppleRequest(_ request: ASAuthorizationAppleIDRequest) {
		request.requestedScopes = [.fullName, .email]
		let nonce = randomNonceString()
		currentNonce = nonce
		request.nonce = sha256(nonce)
	}

	/// Throws if there is an error
	/// Return false if the user canceled sign in
	/// Returns true if sign in was sucessful
	public func handleSignInWithAppleCompletion(_ result: Result<ASAuthorization, Error>) async throws -> Bool {
		print("[AUTH][APPLE][INFO] SignInWithApple Completion Called...")
		if case .failure(let failure) = result {
			if (failure as? ASAuthorizationError)?.code == .canceled {
				print("[AUTH][APPLE][INFO] User cancelled Apple Sign In.")
				return false
			}
			print("[AUTH][APPLE][ERROR] SignInWithApple Info: User cancelled Apple Sign In.")
			throw AuthKitError.defaultSignInWithAppleError
		}
		if case .success(let authResults) = result {

			guard let appleIDCredential = authResults.credential as? ASAuthorizationAppleIDCredential else {
				print("[AUTH][APPLE][ERROR] SignInWithApple Error: Invalid authorization result.")
				throw AuthKitError.defaultSignInWithAppleError
			}

			self.appleIDCredential = appleIDCredential

			guard let nonce = currentNonce else {
				fatalError(
					"[AUTH][APPLE][ERROR]: Invalid state: A login callback was received, but no login request was sent."
				)
			}
			guard let appleIDToken = appleIDCredential.identityToken else {
				print("[AUTH][APPLE][ERROR] SignInWithApple Error: Unable to fetch identity token.")
				throw AuthKitError.defaultSignInWithAppleError
			}
			guard let idTokenString = String(data: appleIDToken, encoding: .utf8) else {
				print(
					"[AUTH][APPLE][ERROR] SignInWithApple Error: Unable to serialize token string from data: \(appleIDToken.debugDescription)"
				)
				throw AuthKitError.defaultSignInWithAppleError
			}

			do {
				try await _db.auth.signInWithIdToken(
					credentials: .init(provider: .apple, idToken: idTokenString, nonce: nonce))

				print("[AUTH][APPLE][SUCCESS] SignInWithApple Successfully Signed In.")
				return true
			} catch {
				print("[AUTH][APPLE][ERROR] SignInWithApple Supabase Error: \(error.localizedDescription)")
				throw AuthKitError.defaultSignInWithAppleError
			}
		}

		// Fallback -> do as if the user canceled
		return false
	}

	private func randomNonceString(length: Int = 32) -> String {
		precondition(length > 0)
		var randomBytes = [UInt8](repeating: 0, count: length)
		let errorCode = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &randomBytes)
		if errorCode != errSecSuccess {
			fatalError(
				"[AUTH][APPLE][ERROR] Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)"
			)
		}

		let charset: [Character] =
			Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")

		let nonce = randomBytes.map { byte in
			// Pick a random character from the set, wrapping around if needed.
			charset[Int(byte) % charset.count]
		}

		return String(nonce)
	}

	private func sha256(_ input: String) -> String {
		let inputData = Data(input.utf8)
		let hashedData = SHA256.hash(data: inputData)
		let hashString = hashedData.compactMap {
			String(format: "%02x", $0)
		}.joined()
		return hashString
	}
}
