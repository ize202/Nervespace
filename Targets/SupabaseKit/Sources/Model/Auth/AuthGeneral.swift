//
//  AuthGeneral.swift
//  SupabaseKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/authkit
//

import Foundation
import SharedKit
import Supabase

//MARK: - Auth Stuff (General)
extension DB {

	// Supabase calls this function when user state changes
	public func registerAuthStateListener(additionalHandler: @escaping (AuthChangeEvent, Session?) -> Void) async {
		if authStateHandler == nil {
			authStateHandler = await _db.auth.onAuthStateChange { event, session in
				print(
					"[AUTH][INFO] Auth State Change: \(event.rawValue)"
				)

				Task { @MainActor in
					self.currentUser = session?.user
					if session?.user != nil {
						self.authState = .signedIn
						
						// Initialize new user when signed in
						if event == .signedIn {
							await self.initializeNewUser()
						}
					} else {
						self.authState = .signedOut
					}
					additionalHandler(event, session)
				}
			}
		}
	}

	public func signOut() async throws {
		print("[AUTH][INFO] Signing Out...")
		do {
			try await _db.auth.signOut()
		} catch {
			print("[DB][ERROR] Couldn't sign out: \(error.localizedDescription)")
			throw AuthKitError.defaultSignOutError
		}
	}

}

//MARK: - Helper functions for Auth-based actions

/// If a function is called via executeIfSignedIn, what to do if the user is not signed in
public enum NotSignedInConsequence {
	/// Just show a notification, telling the user they are not signed in
	case showInAppNotification

	/// Or show the sign in screen
	case showSignInScreen
}

extension DB {

	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		await closure()
	}

	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: UUID?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.id else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: UUID?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.id else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		await closure()
	}

	/// Internal function for the above functionality
	private func _consequenceExecutionForNotSignedIn(_ consequence: NotSignedInConsequence) {
		if consequence == .showInAppNotification {
			showInAppNotification(
				.error, content: .init(title: "Sign In Required", message: "Can't perform this action"),
				size: .compact)
		} else {
			showSignInSheet()
		}
	}
}
