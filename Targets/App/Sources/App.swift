//
//  App.swift
//  App (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/app
//  https://docs.swiftylaun.ch/basics/how-to-work-with-swiftylaunch
//
//  Main entrance of your app.
//  Define your app-wide settings here, objects that are shared within the
//  app via EnvironmentObject, and attach app-wide view modifiers.
//

import NotifKit
import OneSignalFramework
import SharedKit
import SupabaseKit
import SwiftUI
import UIKit
import AnalyticsKit
import CrashlyticsKit
import SuperwallKit

@main
struct MainApp: App {

	// Allows us to tap into AppDelegate
	@UIApplicationDelegateAdaptor(AppDelegate.self) var delegate

	/// Core state objects
	@StateObject private var db: DB
	@StateObject private var progressStore: LocalProgressStore
	@StateObject private var completionStore: RoutineCompletionStore
	@StateObject private var pendingStore: PendingCompletionStore
	@StateObject private var syncManager: SupabaseSyncManager
	@StateObject private var syncCoordinator: SyncCoordinator

	// To track when app goes into foreground/background
	// We use this to clear push notifications when the app is opened.
	@Environment(\.scenePhase) var scenePhase

	init() {
		// Initialize core dependencies first
		let db = DB()
		let progressStore = LocalProgressStore()
		let completionStore = RoutineCompletionStore()
		let pendingStore = PendingCompletionStore()
		
		// Initialize StateObjects using underscore prefix
		_db = StateObject(wrappedValue: db)
		_progressStore = StateObject(wrappedValue: progressStore)
		_completionStore = StateObject(wrappedValue: completionStore)
		_pendingStore = StateObject(wrappedValue: pendingStore)
		
		// Initialize sync management
		let syncManager = SupabaseSyncManager(
			db: db,
			progressStore: progressStore,
			completionStore: completionStore,
			pendingStore: pendingStore
		)
		_syncManager = StateObject(wrappedValue: syncManager)
		
		let coordinator = SyncCoordinator(syncManager: syncManager)
		_syncCoordinator = StateObject(wrappedValue: coordinator)
	}

	var body: some Scene {
		WindowGroup {
			ContentView()
				// Force dark mode
				.preferredColorScheme(.dark)
				.environment(\.colorScheme, .dark)

				// For different types of requests: Camera Request, Location Request, Request to Review the App, etc. See `askUserFor.swift` in SharedKit for more information.
				.modifier(ShowRequestSheetWhenNeededModifier())

				// Will show the WhatsNewView sheet if the user opens the app for the first time with a specific app version (for updates)
//				.modifier(ShowFeatureSheetOnNewAppVersionModifier())

				// Will show the OnboardingView if the user opens the app for the first time
				.modifier(ShowOnboardingViewOnFirstLaunchEverModifier())

				// Will show a sheet that will ask the user to give permission for push notifications, when `PushNotifications.showNotificationsPermissionsSheet()` is called (NotifKit)
				.modifier(ShowPushNotificationPermissionSheetIfNeededModifier())

				// This modifier allows you to show the sign in sheet with the `showSignInSheet` function (SupabaseKit)
				.modifier(ShowSignInSheetWhenCalledModifier(db))

				// Environment Objects
				.environmentObject(db)
				.environmentObject(progressStore)
				.environmentObject(completionStore)
				.environmentObject(pendingStore)
				.environmentObject(syncManager)
				.environmentObject(syncCoordinator)

				// Sync when auth state changes
				.onChange(of: db.authState) { newState in
					if newState == .signedIn {
						// Handle OneSignal setup
						PushNotifications.oneSignalConsentGiven()
						if let userId = db.currentUser?.id {
							PushNotifications.associateUserWithID(userId.uuidString)
						}
						
						// Force sync after sign in
						Task {
							// Small delay to give Supabase time to finish setup_new_user()
							try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5 seconds
							await syncCoordinator.forceSync()
						}
					} else {
						PushNotifications.removeUserIDAssociation()
					}
				}

				// Handle scene phase changes
				.onChange(of: scenePhase) { phase in
					// Handle scene phase changes
					switch phase {
					case .active:
						// App became active
						Task {
							await syncCoordinator.performSync()
						}
					case .background:
						// App went to background
						Task {
							await syncManager.syncLocalToSupabase()
						}
					case .inactive:
						break
					@unknown default:
						break
					}
				}
		}
	}
}

class AppDelegate: NSObject, UIApplicationDelegate, OSNotificationLifecycleListener {

	/// This function is called by the UIApplicationDelegate when App has finished loading and is launched.
	///
	/// Learn more about the app lifecycle [here](https://manasaprema04.medium.com/application-life-cycle-in-ios-f7365d8c1636).
	func application(
		_ application: UIApplication,
		didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
	) -> Bool {

		// Initialize Mixpanel for analytics
		Analytics.initMixpanel()

		// Initialize Sentry for crash reporting
		Crashlytics.shared.configure()

		// Initialize Superwall
		Superwall.configure(apiKey: "pk_9a8863050fddddfe94135b0d907e2e593af2c3dbbd78c6be")

		// If OneSignal initialized successfully, we set up the push notification observers and clear all notifications when the app is opened
		PushNotifications.initOneSignal(launchOptions)

		// To route push notifications to in-app messages, we need to listen to the notification lifecycle
		OneSignal.Notifications.addForegroundLifecycleListener(self)

		// Clear all notifications (if any)
		PushNotifications.clearAllAppNotifications()

		return true
	}

	/// Set SceneDelegate as the delegate for the main window
	func application(
		_ application: UIApplication,
		configurationForConnecting connectingSceneSession: UISceneSession,
		options: UIScene.ConnectionOptions
	)
		-> UISceneConfiguration
	{
		let configuration = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)
		if connectingSceneSession.role == .windowApplication {
			configuration.delegateClass = SceneDelegate.self
		}
		return configuration
	}

	/// Will be called when the app receives a notification AND is in the foreground
	/// https://docs.swiftylaun.ch/module/notifkit/routing-to-in-app-notifications
	func onWillDisplay(event: OSNotificationWillDisplayEvent) {
		event.preventDefault()

		// If we can't find these properties in additional data, just show notification as usual
		guard let notifTitle = event.notification.title,
			let notifMessage = event.notification.body,
			let additionalData = event.notification.additionalData,
			let symbol = additionalData["inAppSymbol"] as? String,
			let color = additionalData["inAppColor"] as? String
		else {
			event.notification.display()
			return
		}

		// optionally you can pass notifSize as a parameter
		var notifSize: InAppNotificationStyle.NotificationSize = .normal
		if let size = additionalData["inAppSize"] as? String {
			if size == "compact" {
				notifSize = .compact
			}
		}

		// optionally you can pass notifHaptics as a parameter
		var notifHaptics: UINotificationFeedbackGenerator.FeedbackType = .warning
		if let size = additionalData["inAppHaptics"] as? String {
			if size == "error" {
				notifHaptics = .error
			} else if size == "success" {
				notifHaptics = .success
			}
		}

		showInAppNotification(
			content: .init(
				title: LocalizedStringKey(notifTitle),
				message: LocalizedStringKey(notifMessage)),
			style: .init(
				sfSymbol: symbol,
				symbolColor: Color(hex: color),
				size: notifSize,
				hapticsOnAppear: notifHaptics))

	}
}
// https://swiftylaun.ch/blog/swiftui-overlay-over-every-view
// https://docs.swiftylaun.ch/module/sharedkit/in-app-notifications
final class SceneDelegate: NSObject, ObservableObject, UIWindowSceneDelegate {

	var keyWindow: UIWindow?
	var secondaryWindow: UIWindow?

	func scene(
		_ scene: UIScene,
		willConnectTo session: UISceneSession,
		options connectionOptions: UIScene.ConnectionOptions
	) {
		if let windowScene = scene as? UIWindowScene {
			setupSecondaryOverlayWindow(in: windowScene)
			
			// Show app launch paywall if needed
			PaywallManager.shared.handleAppLaunch()
		}
		// Change the AccentColor in App/Resources/Assets to style the app
		UIView.appearance(whenContainedInInstancesOf: [UIAlertController.self]).tintColor = UIColor.init(
			named: "AccentColor")
	}

	// Secondary, transparent window for overlays that go over all views.
	func setupSecondaryOverlayWindow(in scene: UIWindowScene) {
		let secondaryViewController = UIHostingController(
			rootView:
				EmptyView()
				.frame(maxWidth: .infinity, maxHeight: .infinity)

				// This modifier allows you to show in-app notifications with the `showInAppNotification` function
				.modifier(ShowInAppNotificationsWhenCalledModifier())

		)
		secondaryViewController.view.backgroundColor = .clear

		let secondaryWindow = PassThroughWindow(windowScene: scene)
		secondaryWindow.rootViewController = secondaryViewController
		secondaryWindow.isHidden = false
		self.secondaryWindow = secondaryWindow
	}
}

class PassThroughWindow: UIWindow {
	override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
		// Get view from superclass.
		guard let hitView = super.hitTest(point, with: event) else { return nil }
		// If the returned view is the `UIHostingController`'s view, ignore.
		return rootViewController?.view == hitView ? nil : hitView
	}
}

