---
description: when needing to see the db schema
globs: 
alwaysApply: false
---
# DB Schema
## This is our current db schema
### This schema supports both authenticated and anonymous users

```sql
-- User Profiles Table (simplified for Sign in with Apple)
CREATE TABLE public.user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    apple_id TEXT UNIQUE NOT NULL,
    email TEXT,
    name TEXT,
    avatar_url TEXT,
    is_premium BOOLEAN DEFAULT FALSE,
    premium_until TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- User Progress Table (simplified, no device_id)
CREATE TABLE public.user_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
    streak INTEGER DEFAULT 0,
    daily_minutes INTEGER DEFAULT 0,
    total_minutes INTEGER DEFAULT 0,
    last_activity DATE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Routine Completions Table (simplified, no device_id)
CREATE TABLE public.routine_completions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
    routine_id TEXT NOT NULL,
    completed_at TIMESTAMPTZ NOT NULL,
    duration_minutes INTEGER NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_user_progress_user_id ON user_progress(user_id);
CREATE INDEX idx_user_progress_last_activity ON user_progress(last_activity);
CREATE INDEX idx_routine_completions_user_id ON routine_completions(user_id);
CREATE INDEX idx_routine_completions_completed_at ON routine_completions(completed_at);

-- Enable Row Level Security
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_progress ENABLE ROW LEVEL SECURITY;
ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for User Profiles
CREATE POLICY "Users can view own profile"
ON user_profiles FOR SELECT
TO authenticated
USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
ON user_profiles FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile"
ON user_profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- RLS Policies for User Progress
CREATE POLICY "Users can view own progress"
ON user_progress FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users can update own progress"
ON user_progress FOR UPDATE
TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- RLS Policies for Routine Completions
CREATE POLICY "Users can view own completions"
ON routine_completions FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own completions"
ON routine_completions FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

-- Database Functions

-- Function to record a routine completion and update progress
CREATE OR REPLACE FUNCTION record_routine_completion(
    p_routine_id TEXT,
    p_duration_minutes INTEGER,
    p_completed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_completion_id UUID;
    v_last_activity DATE;
    v_current_date DATE := CURRENT_DATE;
BEGIN
    -- Insert the completion
    INSERT INTO routine_completions (
        user_id,
        routine_id,
        completed_at,
        duration_minutes
    )
    VALUES (
        auth.uid(),
        p_routine_id,
        p_completed_at,
        p_duration_minutes
    )
    RETURNING id INTO v_completion_id;

    -- Get the last activity date for the user
    SELECT last_activity INTO v_last_activity
    FROM user_progress
    WHERE user_id = auth.uid();

    -- Update or insert user_progress
    INSERT INTO user_progress (
        user_id,
        streak,
        daily_minutes,
        total_minutes,
        last_activity
    )
    VALUES (
        auth.uid(),
        1, -- Initial streak
        p_duration_minutes, -- Initial daily minutes
        p_duration_minutes, -- Initial total minutes
        v_current_date
    )
    ON CONFLICT (user_id) DO UPDATE
    SET 
        streak = CASE 
            WHEN user_progress.last_activity = v_current_date - 1 THEN user_progress.streak + 1
            WHEN user_progress.last_activity = v_current_date THEN user_progress.streak
            ELSE 1
        END,
        daily_minutes = CASE 
            WHEN user_progress.last_activity = v_current_date THEN user_progress.daily_minutes + p_duration_minutes
            ELSE p_duration_minutes
        END,
        total_minutes = user_progress.total_minutes + p_duration_minutes,
        last_activity = v_current_date;

    RETURN v_completion_id;
END;
$$;

-- Function to get user progress
CREATE OR REPLACE FUNCTION get_user_progress()
RETURNS TABLE (
    streak INTEGER,
    daily_minutes INTEGER,
    total_minutes INTEGER,
    last_activity DATE
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        up.streak,
        CASE 
            WHEN up.last_activity = CURRENT_DATE THEN up.daily_minutes
            ELSE 0
        END as daily_minutes,
        up.total_minutes,
        up.last_activity
    FROM user_progress up
    WHERE up.user_id = auth.uid();
END;
$$;

-- Function to get recent completions
CREATE OR REPLACE FUNCTION get_recent_completions(
    p_days INTEGER DEFAULT 30
)
RETURNS TABLE (
    id UUID,
    routine_id TEXT,
    completed_at TIMESTAMPTZ,
    duration_minutes INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rc.id,
        rc.routine_id,
        rc.completed_at,
        rc.duration_minutes
    FROM routine_completions rc
    WHERE rc.user_id = auth.uid()
        AND rc.completed_at >= CURRENT_DATE - p_days
    ORDER BY rc.completed_at DESC;
END;
$$;
```

## Key Changes in Schema

1. User Progress Table:
   - Added `daily_minutes` for tracking daily goals
   - Removed redundant `routine_completions` count
   - Removed `updated_at` timestamp (using `last_activity` instead)
   - Maintained `total_minutes` for lifetime stats

2. Routine Completions Table:
   - Added `duration_minutes` for accurate time tracking
   - Removed redundant `created_at` timestamp
   - Simplified structure for better performance

3. Database Functions:
   - `record_routine_completion`: Handles both tables in one transaction
   - `get_user_progress`: Returns daily and total minutes
   - `get_recent_completions`: Includes duration in results

4. Performance Optimizations:
   - Added index on `last_activity` for streak calculations
   - Maintained existing indexes for user/device lookups
   - Added index on `completed_at` for history queries

## Usage Notes

1. Anonymous Users:
   - Identified by `device_id`
   - No user profile required
   - Progress tracked per device

2. Authenticated Users:
   - Identified by `user_id`
   - Requires user profile
   - Progress syncs across devices

3. Daily vs Total Minutes:
   - `daily_minutes` resets each day
   - `total_minutes` accumulates over time
   - Both updated automatically by `record_routine_completion`

4. Streak Calculation:
   - Increments when activity is on consecutive days
   - Resets when a day is missed
   - Maintains current streak for multiple activities in same day
