---
description: 
globs: 
alwaysApply: true
---
# DB Schema
## This is our current db schema
### This schema supports both authenticated and anonymous users

```sql
-- User Profiles Table
CREATE TABLE public.user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    apple_id TEXT UNIQUE,
    email TEXT,
    name TEXT,
    avatar_url TEXT,
    is_premium BOOLEAN DEFAULT FALSE,
    premium_until TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- User Progress Table (Updated to support anonymous users)
CREATE TABLE public.user_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
    device_id UUID UNIQUE, -- For anonymous users
    streak INTEGER DEFAULT 0,
    routine_completions INTEGER DEFAULT 0,
    total_minutes INTEGER DEFAULT 0,
    last_activity DATE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    -- Ensure either user_id or device_id is present, but not both
    CONSTRAINT check_id_present CHECK (
        (user_id IS NOT NULL AND device_id IS NULL) OR 
        (device_id IS NOT NULL AND user_id IS NULL)
    )
);

-- Indexes for performance
CREATE INDEX idx_user_progress_user_id ON user_progress(user_id);
CREATE INDEX idx_user_progress_device_id ON user_progress(device_id);

-- Enable Row Level Security
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_progress ENABLE ROW LEVEL SECURITY;

-- RLS Policies for User Profiles
CREATE POLICY "Users can view own profile"
ON user_profiles FOR SELECT
TO authenticated
USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
ON user_profiles FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile"
ON user_profiles FOR UPDATE
TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- RLS Policies for User Progress (Updated to support anonymous users)
CREATE POLICY "Users can view own progress"
ON user_progress FOR SELECT
USING (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
);

CREATE POLICY "Users can insert own progress"
ON user_progress FOR INSERT
WITH CHECK (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
);

CREATE POLICY "Users can update own progress"
ON user_progress FOR UPDATE
USING (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
)
WITH CHECK (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
);
```

## Key Changes for Anonymous Users Support

1. Added `device_id` column to `user_progress` table
   - UUID type for unique device identification
   - UNIQUE constraint to prevent duplicates
   - NULL for authenticated users

2. Added constraint `check_id_present`
   - Ensures either `user_id` OR `device_id` is present
   - Prevents having both or neither

3. Updated RLS policies
   - Now supports both authenticated and anonymous access
   - Authenticated users access via `user_id`
   - Anonymous users access via `device_id`

4. Added performance optimizations
   - Index on `device_id` for faster lookups
   - Maintained existing index on `user_id`

## Usage Notes

1. Anonymous Users:
   - Identified by `device_id`
   - No user profile required
   - Progress tracked per device

2. Authenticated Users:
   - Identified by `user_id`
   - Requires user profile
   - Progress syncs across devices

3. Migration Process:
   - When anonymous user creates account:
     1. Create user profile
     2. Copy progress data to new row with `user_id`
     3. Optionally delete anonymous progress 

```sql
-- Routine Completions Table
CREATE TABLE public.routine_completions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id) ON DELETE CASCADE,
    device_id UUID, -- For anonymous users
    routine_id TEXT NOT NULL, -- References the local routine ID from RoutineLibrary
    completed_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    -- Ensure either user_id or device_id is present, but not both
    CONSTRAINT check_id_present CHECK (
        (user_id IS NOT NULL AND device_id IS NULL) OR 
        (device_id IS NOT NULL AND user_id IS NULL)
    )
);

-- Indexes for performance
CREATE INDEX idx_routine_completions_user_id ON routine_completions(user_id);
CREATE INDEX idx_routine_completions_device_id ON routine_completions(device_id);
CREATE INDEX idx_routine_completions_completed_at ON routine_completions(completed_at);

-- Enable Row Level Security
ALTER TABLE routine_completions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for Routine Completions
CREATE POLICY "Users can view own completions"
ON routine_completions FOR SELECT
TO authenticated, anon
USING (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
);

CREATE POLICY "Users can insert own completions"
ON routine_completions FOR INSERT
TO authenticated, anon
WITH CHECK (
    (auth.uid()::uuid = user_id) OR 
    (device_id IS NOT NULL)
);

-- Function to get completions for a user
CREATE OR REPLACE FUNCTION get_user_completions(
    p_start_date TIMESTAMPTZ DEFAULT '-infinity',
    p_end_date TIMESTAMPTZ DEFAULT 'infinity',
    p_user_id UUID DEFAULT NULL,
    p_device_id UUID DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    routine_id TEXT,
    completed_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rc.id,
        rc.routine_id,
        rc.completed_at
    FROM routine_completions rc
    WHERE 
        (p_user_id IS NOT NULL AND rc.user_id = p_user_id) OR
        (p_device_id IS NOT NULL AND rc.device_id = p_device_id)
        AND rc.completed_at >= p_start_date
        AND rc.completed_at <= p_end_date
    ORDER BY rc.completed_at DESC;
END;
$$;

-- Function to record a completion
CREATE OR REPLACE FUNCTION record_routine_completion(
    p_routine_id TEXT,
    p_completed_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    p_user_id UUID DEFAULT NULL,
    p_device_id UUID DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_completion_id UUID;
BEGIN
    -- Insert the completion
    INSERT INTO routine_completions (
        user_id,
        device_id,
        routine_id,
        completed_at
    )
    VALUES (
        p_user_id,
        p_device_id,
        p_routine_id,
        p_completed_at
    )
    RETURNING id INTO v_completion_id;

    -- Update user_progress streak
    -- This ensures streak calculation happens in one place
    IF p_user_id IS NOT NULL THEN
        -- For authenticated users
        UPDATE user_progress
        SET 
            streak = CASE 
                WHEN last_activity::date = CURRENT_DATE - 1 THEN streak + 1
                WHEN last_activity::date = CURRENT_DATE THEN streak
                ELSE 1
            END,
            last_activity = p_completed_at
        WHERE user_id = p_user_id;
    ELSE
        -- For anonymous users
        UPDATE user_progress
        SET 
            streak = CASE 
                WHEN last_activity::date = CURRENT_DATE - 1 THEN streak + 1
                WHEN last_activity::date = CURRENT_DATE THEN streak
                ELSE 1
            END,
            last_activity = p_completed_at
        WHERE device_id = p_device_id;
    END IF;

    RETURN v_completion_id;
END;
$$;
```
